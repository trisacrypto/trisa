syntax = "proto3";

package trisa.gds.api.v1beta1;
option go_package = "github.com/trisacrypto/trisa/pkg/trisa/gds/api/v1beta1;api";

import "ivms101/ivms101.proto";
import "trisa/gds/models/v1beta1/models.proto";
import "trisa/gds/models/v1beta1/ca.proto";

// The TRISADirectory service specifies how TRISA clients should interact with a
// directory service to facilitate P2P transfers.
service TRISADirectory {
    // Interactions with the Directory Service during a TRISA transfer
    // These are the primary Directory Service interactions.
    rpc Lookup(LookupRequest) returns (LookupReply) {}
    rpc Search(SearchRequest) returns (SearchReply) {}

    // Registration workflow and contact verification.
    rpc Register(RegisterRequest) returns (RegisterReply) {}
    rpc VerifyContact(VerifyContactRequest) returns (VerifyContactReply) {}

    // Supplies the entity review and TRISA verification status of a VASP
    rpc Verification(VerificationRequest) returns (VerificationReply) {}

    // Health check and status request that mirrors the TRISAHealth service
    rpc Status(HealthCheck) returns (ServiceState) {}
}

// Lookup VASP certification information either by their unique ID or by the domain of
// the TRISA implementation endpoint, which should be the common name of the certificate.
// Note that if both id and common name are supplied, ID is prioritized.
message LookupRequest {
    // Unique identifier generated by the directory service, most common lookup field.
    string id = 1;

    // The URL of the directory that registered the VASP. If ommitted, it is assumed
    // that the directory being queried is the registering VASP.
    string registered_directory = 2;

    // The common name of the certificate, e.g. the domain name of the TRISA endpoint.
    // To use other name fields such as the legal business name, you must use search.
    string common_name = 3;
}

// Summary information is given in return for VASP lookups as lookups are primarily
// intended to facilitate P2P verification and public key exchange.
// NOTE: only verified VASPs are returned using the lookup RPC.
message LookupReply {
    // If no error is specified, the lookup was successful
    Error error = 1;

    // The uniquely identifying components of the VASP in the directory service
    string id = 2;
    string registered_directory = 3;
    string common_name = 4;

    // The endpoint to connect to for the TRISA P2P protocol (addr:port)
    string endpoint = 5;

    // Certificate information if the VASP is available and verified. The identity
    // certificate is used to establish mTLS connections, the signing certificate is
    // used on a per-transaction basis.
    trisa.gds.models.v1beta1.Certificate identity_certificate = 6;
    trisa.gds.models.v1beta1.Certificate signing_certificate = 7;

    // Other VASP information that faciliates P2P exchanges
    string name = 8;
    string country = 9;
    string verified_on = 10;
}

// Search requests allow a more flexibly field serach to identify a VASP, these requests
// are primarily used to locate a beneficiary VASP in order to begin the TRISA P2P protocol.
// NOTE: only verified VASPs are returned using the search RPC.
message SearchRequest {
    // Case insensitive search fields that use OR to perform the lookup. The name field
    // can be the legal, short, or DBA name of the VASP or the common name of
    // certificate issued to that VASP (though in this case, it is better to use the
    // Lookup RPC). The website must be a parseable URL to lookup the VASP with.
    repeated string name = 1;
    repeated string website = 2;

    // Search filters to condition the search on. Only VASPs that are in the
    // country(ies) or category(ies) specified are returned.
    repeated string country = 7;
    repeated trisa.gds.models.v1beta1.BusinessCategory business_category = 8;
    repeated string vasp_category = 9;
}

message SearchReply {
    message Result {
        // The uniquely identifying components of the VASP in the directory service
        string id = 1;
        string registered_directory = 2;
        string common_name = 3;

        // Address to connect to the remote VASP on to perform a TRISA request
        string endpoint = 4;
    }

    // If no error is specified, the search was successful, even if no results returned.
    Error error = 1;
    repeated Result results = 2;
}

// Registration requests are validated that they contain correct information and then
// are sent through the verification process, creating or updating a VASP as needed.
message RegisterRequest {
    // The legal entity IVMS 101 data for VASP KYC information exchange. This is the
    // IVMS 101 data that should be exchanged in the TRISA P2P protocol as the
    // Originator, Intermediate, or Beneficiary VASP fields. A complete and valid
    // identity record with country of registration is required.
    ivms101.LegalPerson entity = 1;

    // Technical, legal, billing, and administrative contacts for the VASP.
    trisa.gds.models.v1beta1.Contacts contacts = 2;

    // Travel Rule Implementation Endpoint - where other TRISA peers should connect.
    // This should be an addr:port combination, e.g. trisa.vaspbot.net:443
    string trisa_endpoint = 3;

    // Common name should be the VASP domain name to issue certificates for, which
    // should match the domain in the trisa_endpoint. If this field is omitted, the
    // common name is inferred from the trisa_endpoint.
    string common_name = 4;

    // Business Information
    string website = 5;
    trisa.gds.models.v1beta1.BusinessCategory business_category = 6;
    repeated string vasp_categories = 7;
    string established_on = 8; // Should be a date in YYYY-MM-DD format

    // TRIXO Questionnaire
    trisa.gds.models.v1beta1.TRIXOQuestionnaire trixo = 9;
}

message RegisterReply {
     // If the registration was successful, no error will be returned
    Error error = 1;

    // Unique identifiers for the VASP created by the registration.
    // Use these identifiers for status lookup requests and any follow-on interactions.
    string id = 2;
    string registered_directory = 3;
    string common_name = 4;

    // The verification status of the VASP entity.
    trisa.gds.models.v1beta1.VerificationState status = 5;
    string message = 6;

    // Used to decrypt the emailed certificates in PKCS 12 format
    string pkcs12password = 7;
}

message VerifyContactRequest {
    string id = 1;
    string token = 2;
}

message VerifyContactReply {
    // If no error is specified, the verification request was successful.
    Error error = 1;

    // The verification status of the VASP entity.
    trisa.gds.models.v1beta1.VerificationState status = 2;
    string message = 3;
}

// Check on the status of a VASP including its verification status and the service
// status if the TRISA directory service performs health check monitoring. The same
// parameters as the Lookup RPC are sent, but note that a TRISA directory service may
// refuse to return all or part of the status request.
message VerificationRequest {
    // Unique identifier generated by the directory service, most common lookup field.
    string id = 1;

    // The URL of the directory that registered the VASP. If ommitted, it is assumed
    // that the directory being queried is the registering VASP.
    string registered_directory = 2;

    // The common name of the certificate, e.g. the domain name of the TRISA endpoint.
    // To use other name fields such as the legal business name, you must use search.
    string common_name = 3;
}

message VerificationReply {
    // Status information
    trisa.gds.models.v1beta1.VerificationState verification_status = 1;
    trisa.gds.models.v1beta1.ServiceState service_status = 2;
    string verified_on = 3;  // Should be an RFC 3339 Timestamp
    string first_listed = 4; // Should be an RFC 3339 Timestamp
    string last_updated = 5; // Should be an RFC 3339 Timestamp
    string revoked_on = 6; // Should be an RFC 3339 Timestamp
}

message HealthCheck {
    // The number of failed health checks that proceeded the current check.
    uint32 attempts = 1;

    // The timestamp of the last health check, successful or otherwise.
    string last_checked_at = 2;
}

message ServiceState {
    enum Status {
        UNKNOWN = 0;
        HEALTHY = 1;
        UNHEALTHY = 2;
        DANGER = 3;
        OFFLINE = 4;
        MAINTENANCE = 5;
    }

    // Current service status as defined by the recieving system. The system is obliged
    // to respond with the closest matching status in a best-effort fashion. Alerts will
    // be triggered on service status changes if the system does not respond and the
    // previous system state was not unknown.
    Status status = 1;

    // Suggest to the directory service when to check the health status again.
    string not_before = 2;
    string not_after = 3;
}

message Error {
    int32 code = 1;
    string message = 2;
}