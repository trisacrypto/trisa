syntax = "proto3";

package trisa.api.v1beta1;
option go_package = "github.com/trisacrypto/trisa/pkg/trisa/api/v1beta1;api";

import "google/protobuf/any.proto";
import "trisa/api/v1beta1/errors.proto";


// The TRISANetwork service defines the peer-to-peer interactions between VASPs that are
// necessary to conduct compliance information exchanges. All TRISA members must
// implement all services described by the TRISA protocol to ensure that exchanges are
// conducted correctly and securely. The primary RPCs are Transfer and TransactionStream
// which allow VASPs to exchange compliance information before conducting a virtual
// asset transaction. The other RPCs facilitate Transfers, allowing address
// confirmations prior to a transfer and public key exchange so that transaction
// envelopes can be encrypted and signed.
service TRISANetwork {
    // To conduct an information exchange prior to a virtual asset transaction, an
    // originating VASP will send an encrypted transaction envelope to the beneficiary
    // VASP containing a unique ID for the transaction, the encrypted transaction bundle,
    // and metadata associated with the transaction cipher. In response, the beneficiary
    // will validate the transaction request, then return the beneficiary's transaction
    // information using the same unique transaction ID. The TRISANetwork provides both
    // a unary RPC for simple, single transactions and a transaction stream for high
    // throughput transaction workloads.
    rpc Transfer(SecureEnvelope) returns (SecureEnvelope) {}
    rpc TransferStream(stream SecureEnvelope) returns (stream SecureEnvelope) {}

    // Address confirmation allows an originator VASP to establish that a beneficiary
    // VASP has control of a crypto wallet address, prior to sending transaction
    // information with sensitive PII data.
    rpc ConfirmAddress(Address) returns (AddressConfirmation) {}

    // The encrypted transaction envelope uses asymmetric (public/private) encryption to
    // exchange a symmetric key and signature for the transaction blob. To facilitate
    // transaction signatures, VASPs must be able to exchange public signing keys if
    // they have not already obtained them from the directory service.
    rpc KeyExchange(SigningKey) returns (SigningKey) {}
}

// The TRISAHealth service is optional but highly recommended for VASP members to
// implement. The Status endpoint allows the TRISA Directory Service to perform health
// checks with VASP's TrISA Node and report the service conditions of the TRISA network.
// Because a down TRISA node will prevent travel rule compliant virtual asset
// transactions, the health service is intended to quickly identify network problems and
// notify members as quickly as possible.
service TRISAHealth {
    rpc Status(HealthCheck) returns (ServiceState) {}
}


// Encrypted transaction envelope that is the outer layer of the TRISA information
// exchange protocol and facilitates the secure storage of KYC data in a transaction.
// The envelope specifies a unique id to reference the transaction out-of-band (e.g in
// the blockchain layer) and provides the necessary information so that only the
// originator and the beneficiary can decrypt the trnasaction data.
message SecureEnvelope {
    // The transaction identifier generated by the sender. Any response
    // to a transaction request needs to carry the same identifier.
    string id = 1;

    // Encrypted Payload
    bytes payload = 2;

    // Encryption key used to encrypt the transaction blob. This key itself
    // is encrypted using the public key of the receiver.
    bytes encryption_key = 3;

    // The encryption algorithm used to encrypt the transaction blob.
    string encryption_algorithm = 4;

    // HMAC signature calculated from encrypted transaction blob.
    bytes hmac = 5;

    // The HMAC secret used to calculate the HMAC signature. This secret
    // itself is encrypted using the public key of the receiver.
    bytes hmac_secret = 6;

    // The algorithm used to calculate the HMAC signature.
    string hmac_algorithm = 7;

    // Rejection errors are used inside of a streaming context so that the stream is
    // not closed when an exchange-related rejection occurs. In the unary case, errors
    // are directly returned rather than as part of the secure envelope.
    Error error = 9;
}

// Payload is the expected message structure that will be parsed from the encrypted
// secure envelope. The Payload should contain the identity and transaction information
// for the information exchange. The internal message types are purposefully generic to
// allow flexibility with the data needs for different exchanges.
message Payload {
    // Identity contains any valid identity structure. The recommended format is the
    // IVMS101 IdentityPayload which contains the originator and beneficiary identities,
    // the originator and beneficiary VASP identities, as well as the transfer path of
    // any intermediate VASPs. The identity payload can be bidirectional (containing
    // both originator and beneficiary identities) or unidirectional - containing only
    // the identity of the sender. In the bidirectional case, the identity may be
    // purposefully partial to allow the recipient to fill in the details. In the
    // unidirectional case, the identities must be collated after.
    google.protobuf.Any identity = 1;

    // Transaction contains network specific information about the exchange or transfer.
    google.protobuf.Any transaction = 2;
}

// TODO: specify the address confirmation protocol.
message Address {}
message AddressConfirmation {}

// SigningKey provides metadata for decoding a PEM encoded PKIX public key for RSA
// encryption and transaction signing. The SigningKey is a lightweight version of the
// Certificate information stored in the Directory Service.
message SigningKey {
    // x.509 metadata information for ease of reference without parsing the key.
    int64 version = 1;
    bytes signature = 2;
    string signature_algorithm = 3;
    string public_key_algorithm = 4;

    // Validity information
    string not_before = 8;
    string not_after = 9;
    bool revoked = 10;

    // The PEM encoded public key to PKIX, ASN.1 DER form without the trust chain.
    bytes data = 11;
}

message HealthCheck {
    // The number of failed health checks that proceeded the current check.
    uint32 attempts = 1;

    // The timestamp of the last health check, successful or otherwise.
    string last_checked_at = 2;
}

message ServiceState {
    enum Status {
        UNKNOWN = 0;
        HEALTHY = 1;
        UNHEALTHY = 2;
        DANGER = 3;
        OFFLINE = 4;
        MAINTENANCE = 5;
    }

    // Current service status as defined by the recieving system. The system is obliged
    // to respond with the closest matching status in a best-effort fashion. Alerts will
    // be triggered on service status changes if the system does not respond and the
    // previous system state was not unknown.
    Status status = 1;

    // Suggest to the directory service when to check the health status again.
    string not_before = 2;
    string not_after = 3;
}