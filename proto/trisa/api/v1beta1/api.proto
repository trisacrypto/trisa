syntax = "proto3";

package trisa.api.v1beta1;
option go_package = "github.com/trisacrypto/trisa/pkg/trisa/api/v1beta1;api";

import "google/protobuf/any.proto";
import "trisa/api/v1beta1/errors.proto";


// The TRISANetwork service defines the peer-to-peer interactions between VASPs that are
// necessary to conduct compliance information exchanges. All TRISA members must
// implement all services described by the TRISA protocol to ensure that exchanges are
// conducted correctly and securely. The primary RPCs are Transfer and TransferStream
// which allow VASPs to exchange compliance information before conducting a virtual
// asset transaction. The other RPCs facilitate Transfers, allowing address
// confirmations prior to a transfer and public key exchange so that transaction
// envelopes can be encrypted and signed.
service TRISANetwork {
    // To conduct an information exchange prior to a virtual asset transaction, an
    // originating VASP will send an encrypted transaction envelope to the beneficiary
    // VASP containing a unique ID for the transaction, the encrypted transaction bundle,
    // and metadata associated with the transaction cipher. In response, the beneficiary
    // will validate the transaction request, then return the beneficiary's transaction
    // information using the same unique transaction ID. The TRISANetwork provides both
    // a unary RPC for simple, single transactions and a transaction stream for high
    // throughput transaction workloads.
    rpc Transfer(SecureEnvelope) returns (SecureEnvelope) {}
    rpc TransferStream(stream SecureEnvelope) returns (stream SecureEnvelope) {}

    // Address confirmation allows an originator VASP to establish that a beneficiary
    // VASP has control of a crypto wallet address, prior to sending transaction
    // information with sensitive PII data.
    rpc ConfirmAddress(Address) returns (AddressConfirmation) {}

    // The encrypted transaction envelope uses asymmetric (public/private) encryption to
    // exchange a symmetric key and signature for the transaction blob. To facilitate
    // transaction signatures, VASPs must be able to exchange public signing keys if
    // they have not already obtained them from the directory service.
    rpc KeyExchange(SigningKey) returns (SigningKey) {}
}

// The TRISAHealth service is optional but highly recommended for VASP members to
// implement. The Status endpoint allows the TRISA Directory Service to perform health
// checks with VASP's TRISA Node and report the service conditions of the TRISA network.
// Because a down TRISA node will prevent travel rule compliant virtual asset
// transactions, the health service is intended to quickly identify network problems and
// notify members as quickly as possible.
//
// NOTE: the TRISAHealth service must also be behind mTLS so that the health check
// service can verify the identity certificates being used for the TRISANetwork service.
service TRISAHealth {
    rpc Status(HealthCheck) returns (ServiceState) {}
}


// Encrypted transaction envelope that is the outer layer of the TRISA information
// exchange protocol and facilitates the secure storage of KYC data in a transaction.
// The envelope specifies a unique id to reference the transaction out-of-band (e.g in
// the blockchain layer) and provides the necessary information so that only the
// originator and the beneficiary can decrypt the trnasaction data.
message SecureEnvelope {
    // The transaction identifier generated by the sender. Any message concerning the
    // same blockhain transaction requires the same envelope ID on both sending and
    // responding RPCs.
    string id = 1;

    // Encrypted payload that contains the IVMS 101 IdentityPayload for compliance and
    // a generic transaction payload that is used to identify the transaction on the
    // blockchain or perform flow control messages in TRISA itself. This payload should
    // be encrypted using the encryption algorithm and key defined below.
    bytes payload = 2;

    // Encryption key used to encrypt the compliance payload, usually generated on a
    // per-envelope basis. To seal the envelope, this key should be encrypted with the
    // public key of the recipient. If this key is in the clear, the sealed flag should
    // be false.
    bytes encryption_key = 3;

    // The encryption algorithm used to encrypt the compliance payload. This string
    // should provide enough information for the recipient to understand how to decrypt
    // the payload including algorithm, variants, block length, etc.
    string encryption_algorithm = 4;

    // HMAC signature calculated from encrypted encrypted compliance payload using the
    // hmac algorithm and secret defined below. This signature provides non-repudiation
    // to regulators and counterparties that ensure the envelope has not been tampered
    // with after receipt, particularly when comparing two envelopes.
    bytes hmac = 5;

    // The HMAC secret used to calculate the HMAC signature. To seal the envelope, this
    // secret should be encrypted with the public key of the recipient. If this secret
    // is in the clear, the sealed flag should be false.
    bytes hmac_secret = 6;

    // The algorithm used to calculate the HMAC signature. This string should provide
    // enough information for the recipient to understand how to compute the HMAC
    // including algorithm, block length, hashing function, etc.
    string hmac_algorithm = 7;

    // Rejection/TRISA errors should be specified in the SecureEnvelope for correct
    // compliance processing and not returned as a gRPC error. E.g. if the counterparty
    // wishes to send a TRISA error, they should send an OK gRPC response with the error
    // in this field. Networking errors such as unavailable, mTLS failure, or timeouts
    // are handled separately from compliance-related errors.
    Error error = 9;

    // The RFC-3339 formatted timestamp at nanosecond resolution. Used to order
    // SecureEnvelopes related to the same transaction. While this timestamp is likely
    // the same as the sent_at timestamp in the compliance payload, it does not serve
    // the same purpose. The compliance payload timestamps are for non-repudiation,
    // whereas this timestamp is for envelope and communication management.
    string timestamp = 10;

    // Metadata related to the public key cryptography that seal the envelope by
    // encrypting the encryption key and hmac secret such that only the recipient can
    // fully decrypt the envelope. If the envelope is sealed, it indicates that the
    // encryption key and hmac secret are encrypted with a public key, whose signature
    // can be used for the recipient to identify the key pair required for decryption.
    bool sealed = 11;
    string public_key_signature = 12;

    // The state refers to the condition that the sending party feels that the secure
    // envelope exchange is in. This can optionally be used to signal to the
    // counterparty the intent of a transfer message
    TransferState transfer_state = 13;
}

enum TransferState {
    UNSPECIFIED = 0;  // the transfer state is unknown or not specified
    STARTED = 1;      // this is the first message in the TRISA workflow
    PENDING = 2;      // action is required by the sending party
    REPAIR = 3;       // some state of the travel rule exchange requires repair
    ACCEPTED = 4;     // the travel rule exchange is accepted and waiting the transaction
    COMPLETED = 5;    // the travel rule and on-chain transaction have been completed
    REJECTED = 6;     // the travel rule exchange is rejected and should not proceed
}

// Payload contains the compliance identity information that must be exchanged in a
// secure fashion, transaction information for both counterparties to uniquely identify
// the transaction on the chain, and timestamps that are used for regulatory
// non-repudiation. This payload is serialized and encrypted to be sent in the
// SecureEnvelope as well as digitally signed to ensure that the payload has not been
// tampered with after transmission. The internal message types of the payload are
// purposefully generic to allow flexibility with the data needs for different exchanges.
message Payload {
    // Identity contains any valid identity structure. The expected format is the
    // IVMS101 IdentityPayload which contains the originator and beneficiary identities,
    // the originator and beneficiary VASP identities, as well as the transfer path of
    // any intermediate VASPs. The identity payload can be bidirectional (containing
    // both originator and beneficiary identities) or unidirectional - containing only
    // the identity of the sender. In the bidirectional case, the identity may be
    // purposefully partial to allow the recipient to fill in the details. In the
    // unidirectional case, the identities must be collated after.
    google.protobuf.Any identity = 1;

    // Transaction contains network specific information about the exchange or transfer.
    // It can also contain transfer control messages such as Pending messages to
    // facilitate multi-message compliance exchanges. These messages must all be
    // digtially signed for auditing purposes.
    google.protobuf.Any transaction = 2;

    // Timestamps that describe when the payload was originally sent and when it was
    // accepted or received by the counterparty. These timestamps must be in the payload
    // so that they are digitally signed for non-repudiation. Both timestamps should be
    // RFC-3339 formatted strings with timezone information.
    string sent_at = 3;
    string received_at = 4;
}

// Address specifies a crypto address that requires a proof-of-control verification.
// There are three types of verification: simple, key-based, and on-chain. In simple
// address confirmation, the counterparty simply replies y/n if they control the
// address. In key-based control, a token encrypted with the public keys is sent to the
// counterparty which must decrypt it with the private key and return it. In on-chain
// proof-of-control, a transaction is placed on the chain for some small random amount
// of the specified asset, random enough that it can be confirmed by the originator.
message Address {
    // Required fields for all address confirmation RPCs that identify the crypto
    // address and network that needs to be validated as well as the requested type.
    ConfirmationType confirmation = 1;
    string crypto_address = 2;
    string network = 3;

    // Optional details that may be necessary for the specific chain such as the asset
    // type for chains that support multiple assets or a memo/destination tag.
    string asset_type = 4;
    string tag = 5;

    // If the confirmation type is key/token or on-chain then additional details must
    // be specified for the address confirmation. If the confirmation type is simple,
    // then this field may be left empty.
    oneof confirmation_details {
        KeyTokenQuery key_token = 8;
        OnChainQuery on_chain = 9;
    }
}

// AddressConfirmation is returned by the counterparty after receiving an Address
// proof-of-control query. The counterparty should echo the address received (updating
// it as necessary) then specify controlled_by_entity as true if it is controlled by
// the receiving party or false and include an error if it is not. This is sufficient
// for simple address confirmation. For other
message AddressConfirmation {
    // The address that is being confirmed by the counterparty.
    Address address = 1;

    // Specify true if the crypto address is controlled by the counterparty; specifying
    // this as true is sufficient for simple address confirmation. If the counterparty
    // cannot or will not perform the address confirmation they can mark this field as
    // false and include an error code and message. Counterparties that will never do
    // address confirmation should return a gRPC Unimplemented status code to this RPC.
    bool controlled_by_entity = 2;

    // Rejection errors should be specified in the response if the counterparty cannot
    // or will not perform an address confirmation. Generally the error codes that are
    // returned here are UNKNOWN_WALLET_ADDRESS, UNSUPPORTED_NETWORK,
    // UNSUPPORTED_ADDRESS_CONFIRMATION, or CANNOT_CONFIRM_CONTROL_OF_ADDRESS -- but
    // other codes may be used if necessary.
    Error error = 3;

    // If the confirmation type is key/token or on-chain then additional details must
    // be specified for the address confirmation. If the confirmation type is simple,
    // then this field may be left empty.
    oneof confirmation_details {
        KeyTokenConfirm key_token = 8;
        OnChainConfirm on_chain = 9;
    }
}

enum ConfirmationType {
    UNKNOWN = 0;
    SIMPLE = 1;
    KEYTOKEN = 2;
    ONCHAIN = 3;
}

message KeyTokenQuery {
    // A token encrypted by the public key of the wallet address.
    bytes token = 1;

    // The algorithm used to encrypt the token.
    string public_key_algorithm = 4;

    // The signature of the public key, used to identify the key pair.
    string public_key_signature = 12;
}

message KeyTokenConfirm {
    // The decrypted token to confirm to the user that the counterparty has control of
    // the private keys of the crypto address.
    bytes decrypted_token = 1;
}

message OnChainQuery {
    // The beneficiary address of the wallet to send the proof of control amount to.
    string beneficiary_address = 1;

    // Amount of the transaction (usually a small amount) - this is the nonce value.
    double amount = 2;

    // The RFC3339 encoded timestamp of when the transaction must be posted by.
    string not_after = 3;
}

message OnChainConfirm {
    // The RFC3339 encoded timestamp of when transaction will be visible.
    string not_before = 1;

    // The actual amount posted in the transaction for verification.
    double amount = 2;

    // The transaction ID of the confirmation, if available
    string txid = 3;
}

// SigningKey provides metadata for decoding a PEM encoded PKIX public key for RSA
// encryption and transaction signing. The SigningKey is a lightweight version of the
// Certificate information stored in the Directory Service.
message SigningKey {
    // x.509 metadata information for ease of reference without parsing the key.
    int64 version = 1;
    bytes signature = 2;
    string signature_algorithm = 3;
    string public_key_algorithm = 4;

    // Validity information
    string not_before = 8;
    string not_after = 9;
    bool revoked = 10;

    // The serialized public key to PKIX, ASN.1 DER form.
    bytes data = 11;
}

message HealthCheck {
    // The number of failed health checks that proceeded the current check.
    uint32 attempts = 1;

    // The timestamp of the last health check, successful or otherwise.
    string last_checked_at = 2;
}

message ServiceState {
    enum Status {
        UNKNOWN = 0;
        HEALTHY = 1;
        UNHEALTHY = 2;
        DANGER = 3;
        OFFLINE = 4;
        MAINTENANCE = 5;
    }

    // Current service status as defined by the recieving system. The system is obliged
    // to respond with the closest matching status in a best-effort fashion. Alerts will
    // be triggered on service status changes if the system does not respond and the
    // previous system state was not unknown.
    Status status = 1;

    // Suggest to the directory service when to check the health status again.
    string not_before = 2;
    string not_after = 3;
}