syntax = "proto3";

package trisa.api.v1beta1;
option go_package = "github.com/trisacrypto/trisa/pkg/trisa/api/v1beta1;api";

import "google/protobuf/any.proto";
import "trisa/api/v1beta1/errors.proto";


// The TRISANetwork service defines the peer-to-peer interactions between VASPs that are
// necessary to conduct compliance information exchanges. All TRISA members must
// implement all services described by the TRISA protocol to ensure that exchanges are
// conducted correctly and securely. The primary RPCs are Transfer and TransferStream
// which allow VASPs to exchange compliance information before conducting a virtual
// asset transaction. The other RPCs facilitate Transfers, allowing address
// confirmations prior to a transfer and public key exchange so that transaction
// envelopes can be encrypted and signed.
service TRISANetwork {
    // To conduct an information exchange prior to a virtual asset transaction, an
    // originating VASP will send an encrypted transaction envelope to the beneficiary
    // VASP containing a unique ID for the transaction, the encrypted transaction bundle,
    // and metadata associated with the transaction cipher. In response, the beneficiary
    // will validate the transaction request, then return the beneficiary's transaction
    // information using the same unique transaction ID. The TRISANetwork provides both
    // a unary RPC for simple, single transactions and a transaction stream for high
    // throughput transaction workloads.
    rpc Transfer(SecureEnvelope) returns (SecureEnvelope) {}
    rpc TransferStream(stream SecureEnvelope) returns (stream SecureEnvelope) {}

    // Address confirmation allows an originator VASP to establish that a beneficiary
    // VASP has control of a crypto wallet address, prior to sending transaction
    // information with sensitive PII data.
    rpc ConfirmAddress(Address) returns (AddressConfirmation) {}

    // The encrypted transaction envelope uses asymmetric (public/private) encryption to
    // exchange a symmetric key and signature for the transaction blob. To facilitate
    // transaction signatures, VASPs must be able to exchange public signing keys if
    // they have not already obtained them from the directory service.
    rpc KeyExchange(SigningKey) returns (SigningKey) {}
}

// The TRISAHealth service is optional but highly recommended for VASP members to
// implement. The Status endpoint allows the TRISA Directory Service to perform health
// checks with VASP's TRISA Node and report the service conditions of the TRISA network.
// Because a down TRISA node will prevent travel rule compliant virtual asset
// transactions, the health service is intended to quickly identify network problems and
// notify members as quickly as possible.
//
// NOTE: the TRISAHealth service must also be behind mTLS so that the health check
// service can verify the identity certificates being used for the TRISANetwork service.
service TRISAHealth {
    rpc Status(HealthCheck) returns (ServiceState) {}
}


// Encrypted transaction envelope that is the outer layer of the TRISA information
// exchange protocol and facilitates the secure storage of KYC data in a transaction.
// The envelope specifies a unique id to reference the transaction out-of-band (e.g in
// the blockchain layer) and provides the necessary information so that only the
// originator and the beneficiary can decrypt the trnasaction data.
message SecureEnvelope {
    // The transaction identifier generated by the sender. Any message concerning the
    // same blockhain transaction requires the same envelope ID on both sending and
    // responding RPCs.
    string id = 1;

    // Encrypted payload that contains the IVMS 101 IdentityPayload for compliance and
    // a generic transaction payload that is used to identify the transaction on the
    // blockchain or perform flow control messages in TRISA itself. This payload should
    // be encrypted using the encryption algorithm and key defined below.
    bytes payload = 2;

    // Encryption key used to encrypt the compliance payload, usually generated on a
    // per-envelope basis. To seal the envelope, this key should be encrypted with the
    // public key of the recipient. If this key is in the clear, the sealed flag should
    // be false.
    bytes encryption_key = 3;

    // The encryption algorithm used to encrypt the compliance payload. This string
    // should provide enough information for the recipient to understand how to decrypt
    // the payload including algorithm, variants, block length, etc.
    string encryption_algorithm = 4;

    // HMAC signature calculated from encrypted encrypted compliance payload using the
    // hmac algorithm and secret defined below. This signature provides non-repudiation
    // to regulators and counterparties that ensure the envelope has not been tampered
    // with after receipt, particularly when comparing two envelopes.
    bytes hmac = 5;

    // The HMAC secret used to calculate the HMAC signature. To seal the envelope, this
    // secret should be encrypted with the public key of the recipient. If this secret
    // is in the clear, the sealed flag should be false.
    bytes hmac_secret = 6;

    // The algorithm used to calculate the HMAC signature. This string should provide
    // enough information for the recipient to understand how to compute the HMAC
    // including algorithm, block length, hashing function, etc.
    string hmac_algorithm = 7;

    // Rejection/TRISA errors should be specified in the SecureEnvelope for correct
    // compliance processing and not returned as a gRPC error. E.g. if the counterparty
    // wishes to send a TRISA error, they should send an OK gRPC response with the error
    // in this field. Networking errors such as unavailable, mTLS failure, or timeouts
    // are handled separately from compliance-related errors.
    Error error = 9;

    // The RFC-3339 formatted timestamp at nanosecond resolution. Used to order
    // SecureEnvelopes related to the same transaction. While this timestamp is likely
    // the same as the sent_at timestamp in the compliance payload, it does not serve
    // the same purpose. The compliance payload timestamps are for non-repudiation,
    // whereas this timestamp is for envelope and communication management.
    string timestamp = 10;

    // Metadata related to the public key cryptography that seal the envelope by
    // encrypting the encryption key and hmac secret such that only the recipient can
    // fully decrypt the envelope. If the envelope is sealed, it indicates that the
    // encryption key and hmac secret are encrypted with a public key, whose signature
    // can be used for the recipient to identify the key pair required for decryption.
    bool sealed = 11;
    string public_key_signature = 12;

    // The state refers to the condition that the sending party feels that the secure
    // envelope exchange is in. This can optionally be used to signal to the
    // counterparty the intent of a transfer message
    TransferState transfer_state = 13;
}

enum TransferState {
    UNSPECIFIED = 0;  // the transfer state is unknown or not specified
    STARTED = 1;      // this is the first message in the TRISA workflow
    PENDING = 2;      // action is required by the sending party
    REPAIR = 3;       // some state of the travel rule exchange requires repair
    ACCEPTED = 4;     // the travel rule exchange is accepted and waiting the transaction
    COMPLETED = 5;    // the travel rule and on-chain transaction have been completed
    REJECTED = 6;     // the travel rule exchange is rejected and should not proceed
}

// Payload contains the compliance identity information that must be exchanged in a
// secure fashion, transaction information for both counterparties to uniquely identify
// the transaction on the chain, and timestamps that are used for regulatory
// non-repudiation. This payload is serialized and encrypted to be sent in the
// SecureEnvelope as well as digitally signed to ensure that the payload has not been
// tampered with after transmission. The internal message types of the payload are
// purposefully generic to allow flexibility with the data needs for different exchanges.
message Payload {
    // Identity contains any valid identity structure. The expected format is the
    // IVMS101 IdentityPayload which contains the originator and beneficiary identities,
    // the originator and beneficiary VASP identities, as well as the transfer path of
    // any intermediate VASPs. The identity payload can be bidirectional (containing
    // both originator and beneficiary identities) or unidirectional - containing only
    // the identity of the sender. In the bidirectional case, the identity may be
    // purposefully partial to allow the recipient to fill in the details. In the
    // unidirectional case, the identities must be collated after.
    google.protobuf.Any identity = 1;

    // Transaction contains network specific information about the exchange or transfer.
    // It can also contain transfer control messages such as Pending messages to
    // facilitate multi-message compliance exchanges. These messages must all be
    // digtially signed for auditing purposes.
    google.protobuf.Any transaction = 2;

    // Timestamps that describe when the payload was originally sent and when it was
    // accepted or received by the counterparty. These timestamps must be in the payload
    // so that they are digitally signed for non-repudiation. Both timestamps should be
    // RFC-3339 formatted strings with timezone information.
    string sent_at = 3;
    string received_at = 4;
}

// TODO: specify the address confirmation protocol.
message Address {}
message AddressConfirmation {}

// SigningKey provides metadata for decoding a PEM encoded PKIX public key for RSA
// encryption and transaction signing. The SigningKey is a lightweight version of the
// Certificate information stored in the Directory Service.
message SigningKey {
    // x.509 metadata information for ease of reference without parsing the key.
    int64 version = 1;
    bytes signature = 2;
    string signature_algorithm = 3;
    string public_key_algorithm = 4;

    // Validity information
    string not_before = 8;
    string not_after = 9;
    bool revoked = 10;

    // The serialized public key to PKIX, ASN.1 DER form.
    bytes data = 11;
}

message HealthCheck {
    // The number of failed health checks that proceeded the current check.
    uint32 attempts = 1;

    // The timestamp of the last health check, successful or otherwise.
    string last_checked_at = 2;
}

message ServiceState {
    enum Status {
        UNKNOWN = 0;
        HEALTHY = 1;
        UNHEALTHY = 2;
        DANGER = 3;
        OFFLINE = 4;
        MAINTENANCE = 5;
    }

    // Current service status as defined by the recieving system. The system is obliged
    // to respond with the closest matching status in a best-effort fashion. Alerts will
    // be triggered on service status changes if the system does not respond and the
    // previous system state was not unknown.
    Status status = 1;

    // Suggest to the directory service when to check the health status again.
    string not_before = 2;
    string not_after = 3;
}