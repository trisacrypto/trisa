// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.2
// source: trisa/api/v1beta1/api.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	TRISANetwork_Transfer_FullMethodName       = "/trisa.api.v1beta1.TRISANetwork/Transfer"
	TRISANetwork_TransferStream_FullMethodName = "/trisa.api.v1beta1.TRISANetwork/TransferStream"
	TRISANetwork_ConfirmAddress_FullMethodName = "/trisa.api.v1beta1.TRISANetwork/ConfirmAddress"
	TRISANetwork_KeyExchange_FullMethodName    = "/trisa.api.v1beta1.TRISANetwork/KeyExchange"
)

// TRISANetworkClient is the client API for TRISANetwork service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The TRISANetwork service defines the peer-to-peer interactions between VASPs that are
// necessary to conduct compliance information exchanges. All TRISA members must
// implement all services described by the TRISA protocol to ensure that exchanges are
// conducted correctly and securely. The primary RPCs are Transfer and TransferStream
// which allow VASPs to exchange compliance information before conducting a virtual
// asset transaction. The other RPCs facilitate Transfers, allowing address
// confirmations prior to a transfer and public key exchange so that transaction
// envelopes can be encrypted and signed.
type TRISANetworkClient interface {
	// To conduct an information exchange prior to a virtual asset transaction, an
	// originating VASP will send an encrypted transaction envelope to the beneficiary
	// VASP containing a unique ID for the transaction, the encrypted transaction bundle,
	// and metadata associated with the transaction cipher. In response, the beneficiary
	// will validate the transaction request, then return the beneficiary's transaction
	// information using the same unique transaction ID. The TRISANetwork provides both
	// a unary RPC for simple, single transactions and a transaction stream for high
	// throughput transaction workloads.
	Transfer(ctx context.Context, in *SecureEnvelope, opts ...grpc.CallOption) (*SecureEnvelope, error)
	TransferStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SecureEnvelope, SecureEnvelope], error)
	// Address confirmation allows an originator VASP to establish that a beneficiary
	// VASP has control of a crypto wallet address, prior to sending transaction
	// information with sensitive PII data.
	ConfirmAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*AddressConfirmation, error)
	// The encrypted transaction envelope uses asymmetric (public/private) encryption to
	// exchange a symmetric key and signature for the transaction blob. To facilitate
	// transaction signatures, VASPs must be able to exchange public signing keys if
	// they have not already obtained them from the directory service.
	KeyExchange(ctx context.Context, in *SigningKey, opts ...grpc.CallOption) (*SigningKey, error)
}

type tRISANetworkClient struct {
	cc grpc.ClientConnInterface
}

func NewTRISANetworkClient(cc grpc.ClientConnInterface) TRISANetworkClient {
	return &tRISANetworkClient{cc}
}

func (c *tRISANetworkClient) Transfer(ctx context.Context, in *SecureEnvelope, opts ...grpc.CallOption) (*SecureEnvelope, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SecureEnvelope)
	err := c.cc.Invoke(ctx, TRISANetwork_Transfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tRISANetworkClient) TransferStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SecureEnvelope, SecureEnvelope], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TRISANetwork_ServiceDesc.Streams[0], TRISANetwork_TransferStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SecureEnvelope, SecureEnvelope]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TRISANetwork_TransferStreamClient = grpc.BidiStreamingClient[SecureEnvelope, SecureEnvelope]

func (c *tRISANetworkClient) ConfirmAddress(ctx context.Context, in *Address, opts ...grpc.CallOption) (*AddressConfirmation, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddressConfirmation)
	err := c.cc.Invoke(ctx, TRISANetwork_ConfirmAddress_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tRISANetworkClient) KeyExchange(ctx context.Context, in *SigningKey, opts ...grpc.CallOption) (*SigningKey, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SigningKey)
	err := c.cc.Invoke(ctx, TRISANetwork_KeyExchange_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TRISANetworkServer is the server API for TRISANetwork service.
// All implementations must embed UnimplementedTRISANetworkServer
// for forward compatibility.
//
// The TRISANetwork service defines the peer-to-peer interactions between VASPs that are
// necessary to conduct compliance information exchanges. All TRISA members must
// implement all services described by the TRISA protocol to ensure that exchanges are
// conducted correctly and securely. The primary RPCs are Transfer and TransferStream
// which allow VASPs to exchange compliance information before conducting a virtual
// asset transaction. The other RPCs facilitate Transfers, allowing address
// confirmations prior to a transfer and public key exchange so that transaction
// envelopes can be encrypted and signed.
type TRISANetworkServer interface {
	// To conduct an information exchange prior to a virtual asset transaction, an
	// originating VASP will send an encrypted transaction envelope to the beneficiary
	// VASP containing a unique ID for the transaction, the encrypted transaction bundle,
	// and metadata associated with the transaction cipher. In response, the beneficiary
	// will validate the transaction request, then return the beneficiary's transaction
	// information using the same unique transaction ID. The TRISANetwork provides both
	// a unary RPC for simple, single transactions and a transaction stream for high
	// throughput transaction workloads.
	Transfer(context.Context, *SecureEnvelope) (*SecureEnvelope, error)
	TransferStream(grpc.BidiStreamingServer[SecureEnvelope, SecureEnvelope]) error
	// Address confirmation allows an originator VASP to establish that a beneficiary
	// VASP has control of a crypto wallet address, prior to sending transaction
	// information with sensitive PII data.
	ConfirmAddress(context.Context, *Address) (*AddressConfirmation, error)
	// The encrypted transaction envelope uses asymmetric (public/private) encryption to
	// exchange a symmetric key and signature for the transaction blob. To facilitate
	// transaction signatures, VASPs must be able to exchange public signing keys if
	// they have not already obtained them from the directory service.
	KeyExchange(context.Context, *SigningKey) (*SigningKey, error)
	mustEmbedUnimplementedTRISANetworkServer()
}

// UnimplementedTRISANetworkServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTRISANetworkServer struct{}

func (UnimplementedTRISANetworkServer) Transfer(context.Context, *SecureEnvelope) (*SecureEnvelope, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Transfer not implemented")
}
func (UnimplementedTRISANetworkServer) TransferStream(grpc.BidiStreamingServer[SecureEnvelope, SecureEnvelope]) error {
	return status.Errorf(codes.Unimplemented, "method TransferStream not implemented")
}
func (UnimplementedTRISANetworkServer) ConfirmAddress(context.Context, *Address) (*AddressConfirmation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConfirmAddress not implemented")
}
func (UnimplementedTRISANetworkServer) KeyExchange(context.Context, *SigningKey) (*SigningKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KeyExchange not implemented")
}
func (UnimplementedTRISANetworkServer) mustEmbedUnimplementedTRISANetworkServer() {}
func (UnimplementedTRISANetworkServer) testEmbeddedByValue()                      {}

// UnsafeTRISANetworkServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TRISANetworkServer will
// result in compilation errors.
type UnsafeTRISANetworkServer interface {
	mustEmbedUnimplementedTRISANetworkServer()
}

func RegisterTRISANetworkServer(s grpc.ServiceRegistrar, srv TRISANetworkServer) {
	// If the following call pancis, it indicates UnimplementedTRISANetworkServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TRISANetwork_ServiceDesc, srv)
}

func _TRISANetwork_Transfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SecureEnvelope)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TRISANetworkServer).Transfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TRISANetwork_Transfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TRISANetworkServer).Transfer(ctx, req.(*SecureEnvelope))
	}
	return interceptor(ctx, in, info, handler)
}

func _TRISANetwork_TransferStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TRISANetworkServer).TransferStream(&grpc.GenericServerStream[SecureEnvelope, SecureEnvelope]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TRISANetwork_TransferStreamServer = grpc.BidiStreamingServer[SecureEnvelope, SecureEnvelope]

func _TRISANetwork_ConfirmAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TRISANetworkServer).ConfirmAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TRISANetwork_ConfirmAddress_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TRISANetworkServer).ConfirmAddress(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _TRISANetwork_KeyExchange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SigningKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TRISANetworkServer).KeyExchange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TRISANetwork_KeyExchange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TRISANetworkServer).KeyExchange(ctx, req.(*SigningKey))
	}
	return interceptor(ctx, in, info, handler)
}

// TRISANetwork_ServiceDesc is the grpc.ServiceDesc for TRISANetwork service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TRISANetwork_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "trisa.api.v1beta1.TRISANetwork",
	HandlerType: (*TRISANetworkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Transfer",
			Handler:    _TRISANetwork_Transfer_Handler,
		},
		{
			MethodName: "ConfirmAddress",
			Handler:    _TRISANetwork_ConfirmAddress_Handler,
		},
		{
			MethodName: "KeyExchange",
			Handler:    _TRISANetwork_KeyExchange_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TransferStream",
			Handler:       _TRISANetwork_TransferStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "trisa/api/v1beta1/api.proto",
}

const (
	TRISAHealth_Status_FullMethodName = "/trisa.api.v1beta1.TRISAHealth/Status"
)

// TRISAHealthClient is the client API for TRISAHealth service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The TRISAHealth service is optional but highly recommended for VASP members to
// implement. The Status endpoint allows the TRISA Directory Service to perform health
// checks with VASP's TRISA Node and report the service conditions of the TRISA network.
// Because a down TRISA node will prevent travel rule compliant virtual asset
// transactions, the health service is intended to quickly identify network problems and
// notify members as quickly as possible.
//
// NOTE: the TRISAHealth service must also be behind mTLS so that the health check
// service can verify the identity certificates being used for the TRISANetwork service.
type TRISAHealthClient interface {
	Status(ctx context.Context, in *HealthCheck, opts ...grpc.CallOption) (*ServiceState, error)
}

type tRISAHealthClient struct {
	cc grpc.ClientConnInterface
}

func NewTRISAHealthClient(cc grpc.ClientConnInterface) TRISAHealthClient {
	return &tRISAHealthClient{cc}
}

func (c *tRISAHealthClient) Status(ctx context.Context, in *HealthCheck, opts ...grpc.CallOption) (*ServiceState, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServiceState)
	err := c.cc.Invoke(ctx, TRISAHealth_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TRISAHealthServer is the server API for TRISAHealth service.
// All implementations must embed UnimplementedTRISAHealthServer
// for forward compatibility.
//
// The TRISAHealth service is optional but highly recommended for VASP members to
// implement. The Status endpoint allows the TRISA Directory Service to perform health
// checks with VASP's TRISA Node and report the service conditions of the TRISA network.
// Because a down TRISA node will prevent travel rule compliant virtual asset
// transactions, the health service is intended to quickly identify network problems and
// notify members as quickly as possible.
//
// NOTE: the TRISAHealth service must also be behind mTLS so that the health check
// service can verify the identity certificates being used for the TRISANetwork service.
type TRISAHealthServer interface {
	Status(context.Context, *HealthCheck) (*ServiceState, error)
	mustEmbedUnimplementedTRISAHealthServer()
}

// UnimplementedTRISAHealthServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTRISAHealthServer struct{}

func (UnimplementedTRISAHealthServer) Status(context.Context, *HealthCheck) (*ServiceState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedTRISAHealthServer) mustEmbedUnimplementedTRISAHealthServer() {}
func (UnimplementedTRISAHealthServer) testEmbeddedByValue()                     {}

// UnsafeTRISAHealthServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TRISAHealthServer will
// result in compilation errors.
type UnsafeTRISAHealthServer interface {
	mustEmbedUnimplementedTRISAHealthServer()
}

func RegisterTRISAHealthServer(s grpc.ServiceRegistrar, srv TRISAHealthServer) {
	// If the following call pancis, it indicates UnimplementedTRISAHealthServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TRISAHealth_ServiceDesc, srv)
}

func _TRISAHealth_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HealthCheck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TRISAHealthServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TRISAHealth_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TRISAHealthServer).Status(ctx, req.(*HealthCheck))
	}
	return interceptor(ctx, in, info, handler)
}

// TRISAHealth_ServiceDesc is the grpc.ServiceDesc for TRISAHealth service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TRISAHealth_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "trisa.api.v1beta1.TRISAHealth",
	HandlerType: (*TRISAHealthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _TRISAHealth_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "trisa/api/v1beta1/api.proto",
}
