package openvasp

import (
	"net/url"
	"strings"

	"github.com/trisacrypto/trisa/pkg/ivms101"
	"github.com/trisacrypto/trisa/pkg/openvasp/lnurl"
	"github.com/trisacrypto/trisa/pkg/openvasp/traddr"
	"github.com/trisacrypto/trisa/pkg/slip0044"
	api "github.com/trisacrypto/trisa/pkg/trisa/api/v1beta1"
	generic "github.com/trisacrypto/trisa/pkg/trisa/data/generic/v1beta1"
	"github.com/trisacrypto/trisa/pkg/trisa/envelope"
	"google.golang.org/protobuf/encoding/protojson"
)

// OpenVASP Application Headers
const (
	APIVersionHeader        = "api-version"
	APIExtensionsHeader     = "api-extensions"
	RequestIdentifierHeader = "request-identifier"
	ContentTypeHeader       = "content-type"
)

// OpenVASP Application Header Values
const (
	APIVersion       = "3.1.0"
	ContentTypeValue = "application/json; charset=utf-8"
	ContentMediaType = "application/json"
	ContentPlainText = "text/plain"
)

// TRISA extensions
const (
	SealedTRISAExtension   = "sealed_trisa_envelope"
	UnsealedTRISAExtension = "unsealed_trisa_envelope"
)

// TRPInfo contains metadata information from the TRP API Headers.
type TRPInfo struct {
	Address           string   // Address can be a Travel Rule Address, LNURL, or URL
	APIVersion        string   // Defaults to the APIVersion of the package
	RequestIdentifier string   // A unique identifier representing the specific transfer
	APIExtensions     []string // The names of any extensions uses in the request
}

func (t TRPInfo) GetURL() (_ string, err error) {
	switch {
	case strings.HasPrefix(t.Address, "lnurl1"), strings.HasPrefix(t.Address, "LNURL1"):
		return lnurl.Decode(t.Address)
	case strings.HasPrefix(t.Address, "ta"):
		return traddr.DecodeURL(t.Address)
	default:
		var u *url.URL
		if u, err = url.Parse(t.Address); err != nil {
			return "", err
		}

		if u.Scheme != "" {
			query := u.Query()
			query.Set("t", "i")
			u.RawQuery = query.Encode()
			return u.String(), nil
		}
	}
	return "", ErrUnknownTravelAddress
}

// Inquiry defines a Travel Rule Protocol payload that contains information about the
// transaction and the originator and beneficiary of the transaction.
type Inquiry struct {
	TRP        *TRPInfo                 `json:"-"`
	Asset      *Asset                   `json:"asset"`
	Amount     float64                  `json:"amount"`
	Callback   string                   `json:"callback"`
	IVMS101    *ivms101.IdentityPayload `json:"IVMS101"`
	Extensions map[string]interface{}   `json:"extensions,omitempty"`
}

type Asset struct {
	DTI     string            `json:"dti,omitempty"`      // digital token identifier as per Digital Token Identifier Foundation
	SLIP044 slip0044.CoinType `json:"slip0044,omitempty"` // registered coin types defined by BIP-0044
}

// The TransactionPayload extension is used to provide information about the
// transaction on the blockchain or network so it can be linked to the identity
// information in the TRP payload.
type TransactionPayload struct {
	// Transaction ID on the blockchain or network.
	TxID string `json:"txid,omitempty"`

	// Crypto address of the originator and beneficiary.
	Originator  string `json:"originator,omitempty"`
	Beneficiary string `json:"beneficiary,omitempty"`

	// Amount and asset type of the transaction.
	Amount    float64 `json:"amount,omitempty"`
	AssetType string  `json:"asset_type,omitempty"`

	// The blockchain or network of the transaction.
	Network string `json:"network,omitempty"`

	// The RFC3339 timestamp of the transaction.
	Timestamp string `json:"timestamp,omitempty"`

	// Tags and extra JSON data about the transaction.
	Tag       string                 `json:"tag,omitempty"`
	ExtraJSON map[string]interface{} `json:"extra_json,omitempty"`
}

// The SealedTRISAEnvelope extension is used to faciliate the TRISA protocol by providing a
// JSON serialized version of the secure envelope that contains the transaction.
type SealedTRISAEnvelope struct {
	Envelope string `json:"envelope"`
}

// The UnsealedTRISAEnvelope extension is used to provide an unsealed version of a
// secure envelope where the key is unencrypted, allowing any party to decrypt the
// payload and access the identity and transaction information.
type UnsealedTRISAEnvelope struct {
	// Transaction ID generated by the originator.
	Id string `json:"id"`

	// The encrypted payload containing the IVMS101 identity and generic transaction.
	Payload []byte `json:"payload"`

	// Encryption key used to encrypt the payload, in this struct the key is unencrypted.
	EncryptionKey       []byte `json:"encryption_key"`
	EncryptionAlgorithm string `json:"encryption_algorithm"`

	// HMAC of the payload to ensure integrity.
	HMAC          []byte `json:"hmac"`
	HMACSecret    []byte `json:"hmac_secret"`
	HMACAlgorithm string `json:"hmac_algorithm"`
}

// Convert a TRISA envelope to a TRP payload. If the envelope is sealed, then this
// returns a payload with the SealedTRISAEnvelope extension. If the envelope is
// unsealed, then this returns a payload with the UnsealedTRISAEnvelope extension.
// If the envelope is in the clear then this returns a standard TRP payload with no
// TRISA extensions.
func EnvelopeToPayload(env *envelope.Envelope) (*Inquiry, error) {
	if env == nil {
		return nil, ErrNilEnvelope
	}

	var err error
	switch env.State() {
	case envelope.Sealed:
		// If sealed, just serialize the envelope to JSON.
		var envBytes []byte
		if envBytes, err = protojson.Marshal(env.Proto()); err != nil {
			return nil, err
		}
		return &Inquiry{
			Extensions: map[string]interface{}{
				SealedTRISAExtension: &SealedTRISAEnvelope{
					Envelope: string(envBytes),
				},
			},
		}, nil
	case envelope.Unsealed:
		// If already unsealed, just return the wrapped envelope.
		proto := env.Proto()
		return &Inquiry{
			Extensions: map[string]interface{}{
				UnsealedTRISAExtension: &UnsealedTRISAEnvelope{
					Id:                  proto.Id,
					Payload:             proto.Payload,
					EncryptionKey:       proto.EncryptionKey,
					EncryptionAlgorithm: proto.EncryptionAlgorithm,
					HMAC:                proto.Hmac,
					HMACSecret:          proto.HmacSecret,
					HMACAlgorithm:       proto.HmacAlgorithm,
				},
			},
		}, nil
	case envelope.Clear:
		// If in the clear, return a standard TRP payload.
		var payload *api.Payload
		if payload, err = env.Payload(); err != nil {
			return nil, err
		}

		// Parse the amount and asset type from the transaction.
		transaction := &generic.Transaction{}
		if err = payload.Transaction.UnmarshalTo(transaction); err != nil {
			return nil, err
		}

		inq := &Inquiry{
			Asset:   &Asset{},
			Amount:  transaction.Amount,
			IVMS101: &ivms101.IdentityPayload{},
		}
		if inq.Asset.SLIP044, err = slip0044.ParseCoinType(transaction.AssetType); err != nil {
			return nil, err
		}

		// Unmarshal the identity into the TRP payload.
		if err = payload.Identity.UnmarshalTo(inq.IVMS101); err != nil {
			return nil, err
		}
		return inq, nil
	case envelope.Unknown:
		return nil, ErrUnknownState
	case envelope.Corrupted:
		return nil, ErrInvalidState
	default:
		return nil, ErrEnvelopeError
	}
}

// InquiryResolution is used to approve or reject a TRP Transfer Inquiry either
// automatically in direct response to the inquiry request or via the callback URL
// specified in the request. One of "approved", "rejected", or "version" should be
// specified to ensure unambiguous results are returned to the caller.
type InquiryResolution struct {
	Version  string    `json:"version,omitempty"`  // the API version of the request
	Approved *Approval `json:"approved,omitempty"` // payment address and callback
	Rejected string    `json:"rejected,omitempty"` // human readable comment (must be specified to reject)
}

// Approval is used to accept a TRP Transfer Inquiry.
type Approval struct {
	Address  string `json:"address"`  // some payment address
	Callback string `json:"callback"` // some implementation defined URL for transfer confirmation
}

// Confirmation JSON data is sent in response to a TransferInquiry via a POST to the
// callback URl. Only one of txid or canceled should be specified. The txid should be
// specified only if the transaction has been broadcasted. Canceled is used to indicate
// that the transfer will not move forward with a human readable comment.
type Confirmation struct {
	TRP      *TRPInfo `json:"-"`
	TXID     string   `json:"txid,omitempty"`     // some asset-specific tx identifier
	Canceled string   `json:"canceled,omitempty"` // human readable comment or null
}

func (c Confirmation) Validate() error {
	if c.TXID == "" && c.Canceled == "" {
		return ErrEmptyConfirmation
	}

	if c.TXID != "" && c.Canceled != "" {
		return ErrAmbiguousConfirmation
	}

	return nil
}

// VersionInfo is returned on the version discoverability endpoint.
type VersionInfo struct {
	Version string `json:"version,omitempty"`
	Vendor  string `json:"vendor,omitempty"`
}

// ExtensionsInfo is returned on the extensions discoverability endpoint.
type ExtensionsInfo struct {
	Required  []string `json:"required,omitempty"`
	Supported []string `json:"supported,omitempty"`
}

// IdentityInfo is returned on the identity discoverability endpoint.
type IdentityInfo struct {
	Name string `json:"name,omitempty"` // company name as incorporated in the commercial registry as a string
	LEI  string `json:"lei,omitempty"`  // the Legal Entity Indentifier (see gleif.org) as string
	X509 string `json:"x509,omitempty"` // x509 certificate in PEM format
}
