package openvasp

import (
	"github.com/trisacrypto/trisa/pkg/ivms101"
	"github.com/trisacrypto/trisa/pkg/slip0044"
	"github.com/trisacrypto/trisa/pkg/trisa/envelope"
	"google.golang.org/protobuf/encoding/protojson"
)

// TRP defines a Travel Rule Protocol payload that contains information about the
// transaction and the originator and beneficiary of the transaction.
type TRP struct {
	Asset      slip0044.CoinType       `json:"asset"`
	Amount     float64                 `json:"amount"`
	Callback   string                  `json:"callback"`
	IVMS101    ivms101.IdentityPayload `json:"IVMS101"`
	Extensions map[string]interface{}  `json:"extensions,omitempty"`
}

// The TransactionPayload extension is used to provide information about the
// transaction on the blockchain or network so it can be linked to the identity
// information in the TRP payload.
type TransactionPayload struct {
	// Transaction ID on the blockchain or network.
	TxID string `json:"txid,omitempty"`

	// Crypto address of the originator and beneficiary.
	Originator  string `json:"originator,omitempty"`
	Beneficiary string `json:"beneficiary,omitempty"`

	// Amount and asset type of the transaction.
	Amount    float64 `json:"amount,omitempty"`
	AssetType string  `json:"asset_type,omitempty"`

	// The blockchain or network of the transaction.
	Network string `json:"network,omitempty"`

	// The RFC3339 timestamp of the transaction.
	Timestamp string `json:"timestamp,omitempty"`

	// Tags and extra JSON data about the transaction.
	Tag       string                 `json:"tag,omitempty"`
	ExtraJSON map[string]interface{} `json:"extra_json,omitempty"`
}

// The SealedTRISAEnvelope extension is used to faciliate the TRISA protocol by providing a
// JSON serialized version of the secure envelope that contains the transaction.
type SealedTRISAEnvelope struct {
	Envelope string `json:"envelope"`
}

// The UnsealedTRISAEnvelope extension is used to provide an unsealed version of a
// secure envelope where the key is unencrypted, allowing any party to decrypt the
// payload and access the identity and transaction information.
type UnsealedTRISAEnvelope struct {
	// Transaction ID generated by the originator.
	Id string `json:"id"`

	// The encrypted payload containing the IVMS101 identity and generic transaction.
	Payload []byte `json:"payload"`

	// Encryption key used to encrypt the payload, in this struct the key is unencrypted.
	EncryptionKey       []byte `json:"encryption_key"`
	EncryptionAlgorithm string `json:"encryption_algorithm"`

	// HMAC of the payload to ensure integrity.
	HMAC          []byte `json:"hmac"`
	HMACSecret    []byte `json:"hmac_secret"`
	HMACAlgorithm string `json:"hmac_algorithm"`
}

// Convert an Envelope to either a SealedTRISAEnvelope or UnsealedTRISAEnvelope for
// compatibility with the TRP extension specification.
func EnvelopeToExtension(env *envelope.Envelope) (interface{}, error) {
	if env == nil {
		return nil, ErrNilEnvelope
	}

	var err error
	switch env.State() {
	case envelope.Sealed:
		// If sealed, just serialize the envelope to JSON.
		var envBytes []byte
		if envBytes, err = protojson.Marshal(env.Proto()); err != nil {
			return nil, err
		}
		return &SealedTRISAEnvelope{Envelope: string(envBytes)}, nil
	case envelope.Clear:
		// If in the clear, encrypt the payload with the key
		var unsealed *envelope.Envelope
		if unsealed, _, err = env.Encrypt(); err != nil {
			return nil, err
		}
		proto := unsealed.Proto()
		return &UnsealedTRISAEnvelope{
			Id:                  proto.Id,
			Payload:             proto.Payload,
			EncryptionKey:       proto.EncryptionKey,
			EncryptionAlgorithm: proto.EncryptionAlgorithm,
			HMAC:                proto.Hmac,
			HMACSecret:          proto.HmacSecret,
			HMACAlgorithm:       proto.HmacAlgorithm,
		}, nil
	case envelope.Unsealed:
		// If already unsealed, just return the wrapped envelope.
		proto := env.Proto()
		return &UnsealedTRISAEnvelope{
			Id:                  proto.Id,
			Payload:             proto.Payload,
			EncryptionKey:       proto.EncryptionKey,
			EncryptionAlgorithm: proto.EncryptionAlgorithm,
			HMAC:                proto.Hmac,
			HMACSecret:          proto.HmacSecret,
			HMACAlgorithm:       proto.HmacAlgorithm,
		}, nil
	case envelope.Unknown:
		return nil, ErrUnknownState
	case envelope.Corrupted:
		return nil, ErrInvalidState
	default:
		return nil, ErrEnvelopeError
	}
}
