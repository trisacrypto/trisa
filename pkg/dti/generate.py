#!/usr/bin/env python3

import os
import glob
import json

from datetime import datetime
from collections import Counter


CODE_FILE = "dti.gen.go"
DATA_GLOB = "testdata/DTI_Data_*.json"
HEADERS = [
    "// Code generated by generate.py. DO NOT EDIT.",
    "// source: %s",
    "",
    "package dti",
    "",
    "var identifiers = []DTI{",
    "",
]


def load_dti_data(path=None):
    if path is None:
        path = find_dti_data()

    with open(path, 'r') as f:
        data = json.load(f)
        return data["records"]


def find_dti_data(pattern=DATA_GLOB):
    latest = None
    fname = None

    for path in glob.glob(pattern):
        basename, _ = os.path.splitext(os.path.basename(path))
        parts = basename.split("_")
        ts = datetime.strptime(parts[-1], "%Y%m%d")

        if latest is None or ts > latest:
            latest = ts
            fname = path

    return fname


def key_analysis(records):
    counts = Counter()
    for record in records:
        counts.update(key_counts(record))
    return counts


def key_counts(d: dict, parent=None) -> Counter:
    counts = Counter()
    for key, val in d.items():
        if parent is not None:
            key = f"{parent}.{key}"

        if isinstance(val, dict):
            counts.update(key_counts(val, parent=key))
        elif isinstance(val, list):
            for item in val:
                if isinstance(item, dict):
                    counts.update(key_counts(item, parent=key))
        else:
            counts[key] += 1

    return counts


def main():
    path = find_dti_data()
    records = load_dti_data(path)

    # counts = key_analysis(records)
    # print(json.dumps(counts, indent=2))

    with open(CODE_FILE, "w") as f:
        f.write("\n".join(HEADERS) % path)

        for record in records:
            header = record.get("Header")
            info = record.get("Informative")
            norm = record.get("Normative")
            shortName = "nil"

            names = info.get("ShortNames")
            if names is not None and len(names) > 0:
                shortName = ", ".join([f'"{n["ShortName"]}"' for n in names])
                shortName = "[]string{" + shortName + "}"

            related = []
            for identifier in info.get("UnderlyingAssetExternalIdentifiers", []):  # noqa
                related.append(identifier.get("UnderlyingAssetExternalIdentifierValue"))  # noqa

            if norm is not None:
                aux = norm.get("AuxiliaryDistributedLedger")
                if aux is not None:
                    related.append(aux)

            related_repr = "nil"
            if len(related) > 0:
                related_repr = ", ".join([f'"{r}"' for r in related])
                related_repr = "[]string{" + related_repr + "}"

            f.write("\t{\n")
            f.write(f"\t\tIdentifier: \"{header.get('DTI')}\",\n")
            f.write(f"\t\tLongName: \"{info.get('LongName')}\",\n")
            f.write(f"\t\tShortNames: {shortName},\n")
            f.write(f"\t\tRelated: {related_repr},\n")
            f.write("\t},\n")

        f.write("}\n")


if __name__ == "__main__":
    main()
